(*
 * THIS IS AN AUTO-GENERATED FILE PRODUCED BY URUZ!
 * DO NOT EDIT THIS FILE, since any changes will be
 * lost when the build is reset via "make clean".
 * This file is based on a user-specified EBNF
 * grammar, which can be edited as desired.
 *)

open Javascript_parser;;
open Javascript_lexer;;

let get_ast (i : in_channel) = 
   Javascript_parser.start Javascript_lexer.token (Lexing.from_channel i)
;;


open Javascript_ast;;

(* exception indicating that a program is more
 * than just a single expression *)
exception NotExpr of program_t
(* exception indicating unimplemented input
 * expression *)
exception UndeclaredVar of ident_t
exception UnimplementedExpr of expr_t 
exception UnimplementedStmt of stmt_t 

(* add printer for above exceptions *)
let _ = Printexc.register_printer (fun ex -> match ex with
| NotExpr(p) -> Some(Printf.sprintf "NotExpr(%s)" (str_program p))
| UndeclaredVar(i) -> Some(Printf.sprintf "UndeclaredVar(%s)" i)
| UnimplementedExpr(e) -> Some(Printf.sprintf "Unimplemented(%s)" (str_expr e))
| UnimplementedStmt(s) -> Some(Printf.sprintf "Unimplemented(%s)" (str_stmt s))
| _ -> None)

(* extract expression from a single-expression program *)
let get_expr = fun p ->
  match p with
  | ExprProgram(_,e) -> e
  | _ -> raise (NotExpr(p))


let parse_string (s : string) = 
   Javascript_parser.start Javascript_lexer.token (Lexing.from_string s)

(* parse input string as an expression *)
let parse_expr = fun s ->
  let p = parse_string s in
  get_expr p
