(*
 * THIS IS AN AUTO-GENERATED FILE PRODUCED BY URUZ!
 * DO NOT EDIT THIS FILE, since any changes will be
 * lost when the build is reset via "make clean".
 * This file is based on a user-specified EBNF
 * grammar, which can be edited as desired.
 *)

open Lexing;;
open Parsing;;
(* open Flags;; *)

(* data type for file positions *)
let filename = ref ""
type pos_t = NoPos | Pos of string*int*int;; (* file,line,col *)

exception Parse_error of string;;
exception Lexing_error of string;;
exception General_error of string;;

(* do_error p s
 *
 * Print error message
 *
 * p - the location of the error
 * s - the error message
 *
 * returns unit
 *)
let do_error (p : pos_t) (s : string) : string =
   ("Error"^
   (match p with
   | NoPos -> ""
   | Pos(file_name,line_num,col_num) -> (" in '"^file_name^
    "' on line "^(string_of_int line_num)^" col "^(string_of_int
    col_num))
   )^
   (": "^s^"\n"))
;;

let die_error (p : pos_t) (s : string) =
   raise (General_error(do_error p s))
;;

(* gets a pos data structure using the current lexing pos *)
let get_current_pos () =
   let p         = symbol_start_pos () in
   let file_name = !filename (*p.Lexing.pos_fname*)  in
   let line_num  = p.Lexing.pos_lnum   in
   let col_num   = (p.Lexing.pos_cnum-p.Lexing.pos_bol+1) in
   Pos(file_name,line_num,col_num)
;;

(* gets a pos data structure from a lexing position *)
let get_pos (p : Lexing.position) =
   let file_name = !filename (*p.Lexing.pos_fname*) in
   let line_num  = p.Lexing.pos_lnum  in
   let col_num   = (p.Lexing.pos_cnum-p.Lexing.pos_bol+1) in
   Pos(file_name,line_num,col_num)
;;

(* dies with a general position-based error *)
let pos_error (s : string) (p : position) = 
   do_error (get_pos p) s
;;

(* dies with a parse error s *)
let parse_error (s : string) = 
   raise (Parse_error(pos_error s (symbol_end_pos ())))
;;

(* dies with a lexing error *)
let lex_error (s : string) (lexbuf : Lexing.lexbuf) = 
   raise (Lexing_error(pos_error s (Lexing.lexeme_end_p lexbuf)))
;;

(* updates the lexer position to the next line
 * (this is used since we skip newlines in the
 *  lexer, but we still wish to remember them
 *  for proper line positions) *)
let do_newline lb = 
   Lexing.new_line lb
;;

(* dies with a system error s *)
let die_system_error (s : string) =
   output_string stderr s;
   output_string stderr "\n";
   exit 1
;;

let rec count_newlines s lb = match s with
  | "" -> 0
  | _  -> let c = String.sub s 0 1 in
          let cs = String.sub s 1 ((String.length s)-1) in
          if (c="\n") then (do_newline lb; 1+(count_newlines cs lb))
                      else (count_newlines cs lb)
;;

let eq_base (a : 'a) (b : 'a) : bool = (a = b) ;;
let rec eq_option (f : 'a -> 'a -> bool) (a : 'a option) (b : 'a option) : bool =
   match (a,b) with
   | (None,None) -> true
   | (Some(a),Some(b)) -> (f a b)
   | _ -> false
;;
let eq_pair (f1 : 'a -> 'a -> bool) (f2 : 'b -> 'b -> bool) ((p1a,p1b) : 'a * 'b) ((p2a,p2b) : 'a * 'b) : bool = ((f1 p1a p2a) && (f2 p1b p2b)) ;;
let eq_list (f : 'a -> 'a -> bool) (l1 : 'a list) (l2 : 'a list) : bool = try List.fold_left2 (fun res l1i l2i -> res && (f l1i l2i)) true l1 l2 with _ -> false;;

let rec str_option (f : 'a -> string) (o : 'a option) : string =
   match o with
   | None -> ""
   | Some(a) -> (f a)
;;

let rec str_pair (f : 'a -> string) (g : 'b -> string) ((a,b) : ('a * 'b)) : string =
   (f a)^""^
   (g b)
;;

let rec str_list (f : 'a -> string) (l : 'a list) : string =
   str_list_helper f l true

and str_list_helper (f : 'a -> string) (l : 'a list) (first : bool) : string =
   match l with
   | [] -> ""
   | a::more -> ((if (not first) then "" else "")^(f a)^(str_list_helper f more false))
let rec str_x_list (f : 'a -> string) (il : 'a list) (comma : string) : string = 
    (fst (List.fold_left
    (fun (str,flag) i ->
      (str^(if flag then "" else comma)^(f i), false)
    ) ("",true) il))
;;

  module IntMap = Map.Make(
  struct
    type t = int
    let compare = compare
  end)

  module StringMap = Map.Make(
  struct
    type t = string
    let compare = compare
  end)

  let my_unescaped s =
    let s = Str.global_replace (Str.regexp "[\\][\r][\n]") "" s in
    let s2 = Str.global_replace (Str.regexp "[\\][\n]") "" s in
    Scanf.unescaped s2

  let strip_quotes (s : string) : (string*bool) =
    let len = String.length s in
    if ((len >= 2) && (String.get s 0)='"' && (String.get s (len-1))='"')
    then (String.sub s 1 (len-2),true) else (s,false)
